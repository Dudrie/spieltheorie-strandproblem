{"version":3,"sources":["../webpack/bootstrap ab44fa4b9ed47c026bd8","SimulationWorker.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","worker","self","beachLength","currentPositions","savedPositions","isSimulating","maxn","depth","currentPly","plyCount","maxDepth","customers","Array","length","fill","lastKioskPos","idxKiosk","indexOf","idxLastKiosk","spotsBetween","calculateCustomers","bestCustomers","bestPos","Number","POSITIVE_INFINITY","turns","freeSpots","idx","push","getPossibleSpots","turn","pop","undefined","prevPos","compareCustomers","forEach","pos","c1","c2","pos1","pos2","plyId","addEventListener","ev","console","log","data","results","k","positions","simulate","count","workerReturn","postMessage"],"mappings":"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","file":"ab44fa4b9ed47c026bd8.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/spieltheorie-strandproblem/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ab44fa4b9ed47c026bd8","import { ResultType } from './App';\r\n\r\nconst worker: Worker = self as any;\r\n\r\nexport type WorkerInputData = { length: number; count: number; };\r\nexport type WorkerReturnData = { results: ResultType[] };\r\n\r\nlet isSimulating: boolean = false;\r\nlet beachLength: number;\r\nlet currentPositions: number[];\r\nlet savedPositions: number[];\r\n\r\nworker.addEventListener('message', (ev) => {\r\n    console.log('[WORKER] got data');\r\n    let data: WorkerInputData = ev.data as WorkerInputData;\r\n\r\n    if (!isSimulating) {\r\n        isSimulating = true;\r\n        console.log('[WORKER] starting simulation');\r\n        beachLength = data.length;\r\n\r\n        let results = simulate(data.count);\r\n\r\n        // console.log('Pos');\r\n        // console.log(savedPositions);\r\n        // console.log('Customers');\r\n        // console.log(results[0].customers);\r\n        \r\n        console.log('[WORKER] simulation done -- sending results');\r\n        let workerReturn: WorkerReturnData = {\r\n            results,\r\n        };\r\n        worker.postMessage(workerReturn);\r\n        isSimulating = false;\r\n    }\r\n});\r\n\r\nfunction simulate(plyCount: number): ResultType[] {\r\n    let results: ResultType[] = [];\r\n    savedPositions = new Array(plyCount).fill(-1);\r\n\r\n    // Simulate, considering player with ID 0 starts.\r\n    // let customers: number[] = maxn(plyCount, 0, plyCount, plyCount);\r\n    let customers: number[] = [];\r\n\r\n    for (let i = 0; i < plyCount; i++) {\r\n        currentPositions = new Array(plyCount).fill(-1);\r\n\r\n        for (let k = 0; k < i; k++) {\r\n            currentPositions[k] = savedPositions[k];\r\n\r\n        }\r\n\r\n        customers = maxn(plyCount - i, i, plyCount, plyCount - i);\r\n    }\r\n\r\n    // After it, savedPositions should be the best positions while customers should be the customers for the kiosks.\r\n    results.push({\r\n        positions: savedPositions,\r\n        customers\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\nfunction maxn(depth: number, currentPly: number, plyCount: number, maxDepth: number): number[] {\r\n    if (depth === 0) {\r\n        return calculateCustomers();\r\n    }\r\n\r\n    let bestCustomers: number[] = new Array(plyCount).fill(0);\r\n    let bestPos: number = Number.POSITIVE_INFINITY;\r\n    let turns: number[] = getPossibleSpots();\r\n\r\n    while (turns.length > 0) {\r\n        let turn: number | undefined = turns.pop();\r\n        // console.log('Turn: ' + turn);\r\n        if (turn === undefined) {\r\n            continue;\r\n        }\r\n\r\n        // Do the turn\r\n        let prevPos: number = currentPositions[currentPly];\r\n        currentPositions[currentPly] = turn;\r\n\r\n        // Go one level deeper in the tree and get the customers.\r\n        let customers = maxn(depth - 1, currentPly + 1, plyCount, maxDepth);\r\n\r\n        // Check if this variant is better than the previous one (for the specific player!)\r\n        if (compareCustomers(customers, bestCustomers, turn, bestPos, currentPly) > 0) {\r\n            // It's better\r\n            bestCustomers = customers;\r\n            if (depth === maxDepth) {\r\n                savedPositions = new Array(plyCount).fill(-1);\r\n                currentPositions.forEach((pos, idx) => savedPositions[idx] = pos);\r\n            }\r\n        }\r\n\r\n        // Undo the turn made\r\n        currentPositions[currentPly] = prevPos;\r\n    }\r\n\r\n    return bestCustomers;\r\n}\r\n\r\n/**\r\n * Returns the number of customers of every player as an array. Keys are the player IDs.\r\n * @returns Array with the amount of customers per player\r\n */\r\nfunction calculateCustomers(): number[] {\r\n    let customers: number[] = new Array(currentPositions.length).fill(0);\r\n    let lastKioskPos: number = -1;\r\n\r\n    for (let i = 0; i < beachLength; i++) {\r\n        let idxKiosk: number = currentPositions.indexOf(i);\r\n        let idxLastKiosk: number = currentPositions.indexOf(lastKioskPos);\r\n\r\n        if (idxKiosk !== -1) {\r\n            // We found a kiosk at the given spot. Calculate it's customers\r\n            let spotsBetween: number = i - lastKioskPos - 1; // Do NOT count the both spots with the kiosks\r\n\r\n            if (lastKioskPos === -1) {\r\n                // We found the FIRST kiosk, so just add all spots and his own\r\n                customers[idxKiosk] = spotsBetween + 1;\r\n\r\n            } else {\r\n                // We found an additional one, so do some calculation magic\r\n                customers[idxKiosk] = (spotsBetween / 2) + 1;\r\n                customers[idxLastKiosk] = customers[idxLastKiosk] + (spotsBetween / 2);\r\n\r\n            }\r\n\r\n            lastKioskPos = i;\r\n        }\r\n\r\n        if (i === beachLength - 1) {\r\n            // We're add the end, so add all customors between the end and the last kiosk to the last kiosk\r\n            customers[idxLastKiosk] = customers[idxLastKiosk] + (beachLength - 1 - lastKioskPos);\r\n            // console.log(idxLastKiosk, customers[idxLastKiosk]);\r\n        }\r\n    }\r\n\r\n    return customers;\r\n}\r\n\r\n/**\r\n * Compares the two customer-array in regards of the customer count and (if a tie occurs) on the basis of the positioning.\r\n * @param c1 Customers now\r\n * @param c2 Customers before\r\n * @param pos1 Position now\r\n * @param pos2 Positien before\r\n * @param plyId ID of the player\r\n */\r\nfunction compareCustomers(c1: number[], c2: number[], pos1: number, pos2: number, plyId: number, ): number {\r\n    if (c1[plyId] > c2[plyId]) {\r\n        return 1;\r\n    }\r\n\r\n    if (c1[plyId] < c2[plyId]) {\r\n        return -1;\r\n    }\r\n\r\n    // Tie in regards of the customers, so let the position decide, but in descending manner (more on the left = better)\r\n    if (pos1 < pos2) {\r\n        return 1;\r\n    }\r\n\r\n    if (pos1 > pos2) {\r\n        return -1;\r\n    }\r\n\r\n    // The two customer counts are equall\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Returns an array containing all free spots (so all spots where the player can put it's kiosk).\r\n * @returns Array containing all free spots.\r\n */\r\nfunction getPossibleSpots(): number[] {\r\n    let freeSpots: number[] = [];\r\n\r\n    for (let i = 0; i < beachLength; i++) {\r\n        let idx = currentPositions.indexOf(i);\r\n\r\n        if (idx === -1) {\r\n            freeSpots.push(i);\r\n        }\r\n    }\r\n\r\n    return freeSpots;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/SimulationWorker.tsx"],"sourceRoot":""}