{"version":3,"sources":["../webpack/bootstrap 1e8797a605ef74c85410","SimulationWorker.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","worker","self","isSimulating","addOnePosition","positions","idx","maxPos","hasDuplicateEntries","array","length","indexOf","addEventListener","ev","console","log","data","workerReturn","results","count","k","push","customers","done","result","forEach","pos","lastKioskPos","idxKiosk","idxLastKiosk","spotsBetween","simulate","postMessage"],"mappings":"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","file":"1e8797a605ef74c85410.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/spieltheorie-strandproblem/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1e8797a605ef74c85410","import { ResultType } from './App';\r\n\r\nconst worker: Worker = self as any;\r\n\r\nexport type WorkerInputData = { length: number; count: number; };\r\nexport type WorkerReturnData = { results: ResultType[] };\r\n\r\nlet isSimulating: boolean = false;\r\n\r\nworker.addEventListener('message', (ev) => {\r\n    console.log('Worker got data');\r\n    let data: WorkerInputData = ev.data as WorkerInputData;\r\n\r\n    if (!isSimulating) {\r\n        isSimulating = true;\r\n        let results = simulate(data.length, data.count);\r\n\r\n        let workerReturn: WorkerReturnData = {\r\n            results,\r\n        };\r\n        worker.postMessage(workerReturn);\r\n    }\r\n});\r\n\r\nfunction simulate(length: number, count: number): ResultType[] {\r\n    let results: ResultType[] = [];\r\n\r\n    let positions: number[] = [];\r\n    let maxPos: number = length - 1;\r\n\r\n    for (let k = 0; k < count; k++) {\r\n        positions[k] = 0;\r\n    }\r\n\r\n    if (positions.length === 1) {\r\n        // The algorithem used in addOnePosition(..) misses the first result if positions only contains one element. We'll add this edge case 'manually'.\r\n        results.push({\r\n            positions: [positions[0]],\r\n            customers: []\r\n        });\r\n    }\r\n\r\n    let done: boolean = false;\r\n    while (!done) {\r\n        addOnePosition(positions, positions.length - 1, maxPos);\r\n        // console.log('P: ');\r\n        // console.log(positions);\r\n\r\n        let result: number[] = [];\r\n        positions.forEach((pos, idx) => result[idx] = pos);\r\n\r\n        // Search for duplicates. If there are any, don't add it\r\n        if (!hasDuplicateEntries(result)) {\r\n            results.push({\r\n                positions: result,\r\n                customers: []\r\n            });\r\n        }\r\n\r\n        // Check if we're done. The kiosk have to be positioned correctly in the last spots DESCENDING.\r\n        // We're assuming that we're done. If we find one kiosk which does not fit to the above we have to continue.\r\n        done = true;\r\n        for (let i = 0; i < positions.length; i++) {\r\n            if (positions[i] !== maxPos - i) {\r\n                done = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    console.log('positions set');\r\n\r\n    // Calculate the amount of customers everybody gets.\r\n    console.log('calculate customers');\r\n    results.forEach((result) => {\r\n        let customers: number[] = [];\r\n        let lastKioskPos: number = -1;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            let idxKiosk: number = result.positions.indexOf(i);\r\n            let idxLastKiosk: number = result.positions.indexOf(lastKioskPos);\r\n\r\n            if (idxKiosk !== -1) {\r\n                // We found a kiosk at the given spot. Calculate it's customers\r\n                let spotsBetween: number = i - lastKioskPos - 1; // Do NOT count the both spots with the kiosk\r\n\r\n                if (lastKioskPos === -1) {\r\n                    // We found the FIRST kiosk, so just add all spots and his own\r\n                    customers[idxKiosk] = spotsBetween + 1;\r\n\r\n                } else {\r\n                    // We found an additional one, so do some calculation magic\r\n                    customers[idxKiosk] = (spotsBetween / 2) + 1;\r\n                    customers[idxLastKiosk] = customers[idxLastKiosk] + (spotsBetween / 2);\r\n\r\n                }\r\n\r\n                lastKioskPos = i;\r\n            }\r\n\r\n            if (i === length - 1) {\r\n                // We're add the end, so add all customors between the end and the last kiosk to the last kiosk\r\n                customers[idxLastKiosk] = customers[idxLastKiosk] + (length - 1 - lastKioskPos);\r\n                // console.log(idxLastKiosk, customers[idxLastKiosk]);\r\n            }\r\n        }\r\n\r\n        result.customers = customers;\r\n\r\n        // console.log('R ' + result.customers);\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\nfunction addOnePosition(positions: number[], idx: number, maxPos: number) {\r\n    if (idx === 0) {\r\n        // Only increase the first position if we're not at the max position.\r\n        if (positions[0] < maxPos) {\r\n            positions[0] = positions[0] + 1;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    positions[idx] = positions[idx] + 1;\r\n\r\n    if (positions[idx] > maxPos) {\r\n        // We are higher than the maximal posible position\r\n        positions[idx] = 0;\r\n        addOnePosition(positions, idx - 1, maxPos);\r\n    }\r\n}\r\n\r\nfunction hasDuplicateEntries(array: number[]): boolean {\r\n    for (let i = 0; i < array.length - 1; i++) {\r\n        if (array.indexOf(array[i], i + 1) !== -1) {\r\n            // Found a duplicate\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/SimulationWorker.tsx"],"sourceRoot":""}